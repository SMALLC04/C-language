# 字符串
以0（整数0）为结尾的一串字符，0和'\0'是一样的，就指整数0，和'0'不一样，'0'是一个单字符  
0标志字符串的借宿，但它不是字符串的一部分，计算字符串长度时不计入  
字符串以数组的形式存在，以数组或指针的形式访问，更多的是以指针的形式  
string.h里有很多处理字符串的函数
## 字符串变量
语法格式  
1. `char *str = "hello";`
2. `char str[] = "hello";`
3. `char str[10] = "hello";`
### 注意
**c语言的字符串是以字符数组的形态存在的，不能用运算符对字符串进行运算（比如用+来连接字符串），可以通过数组的方式来遍历字符串**

## 字符串常量
` char *s = "hello,world!";`  
* s是一个指针，初始化为指向一个字符串常量，由于这个字符串常量所在的地方，所以实际上s是const chat *s
* 于是如果尝试通过指针s对字符串进行写入会导致严重的后果
* 如果需要修改字符串，应该用数组
```C
char s[] = "hello";
char s[0] = "H";
```
### 那么我们是该使用指针还是数组去定义字符串呢
* 如果要构造一个字符串就使用数组
* 如果要处理一个字符串就使用指针

### char\*是不是字符串
字符串可以表达为char\*的形式，但char\*不一定就是字符串  
在C语言中，char*是一个指向字符数组的指针，而字符数组通常用于存储字符串。因此，char*通常被用来表示一个字符串。  
然而，char*也可以指向一个单个字符，或者是一个字符数组中的任意一部分，这种情况下它并不代表一个完整的字符串。  
例如，下面的代码定义了一个char*指针，但它指向的并不是一个完整的字符串：  
```C
char arr[] = {'H', 'e', 'l', 'l', 'o'};
char* ptr = &arr[0];

```
在这个例子中，ptr指向字符数组arr的第一个元素，它并不包含一个null终止符来标记字符串的结尾，因此它不是一个完整的字符串。  
因此，需要根据实际情况来判断char*是否代表一个字符串。  
如果不确定char*指向的是一个完整的字符串，应该进行一些安全检查，避免程序出现未定义的行为。  

## 字符串的输入输出
转义格式：%As（在scanf里用A来向scanf说明将要输入几个字符，这是安全的）  
scanf语句  
scanf读入一个单词（到空格、tab或回车为止）

### 常见错误
以为char\*是字符串类型，所以就不去初始化直接对他定义后写入，可能会出现错误
## 空字符串
`char butter[] = "";`  
这是一个空字符串，第一个字符是0，没有字符数量的限制
## 字符串函数

### 输入输出字符函数
1. getchar()函数---输入字符函数
 - 向标准（或者说一个int变量）输入读入一个字符
 - 返回类型是int
 - 输入ctrl+Z输入文本结束符EOF

2. putchar()函数---输出字符函数
 - 向标准（或者说用户）输出一个字符

#### 为什么我们在交互窗口输入完成后电脑无法识别我们输入完成，而是继续等待我们输入？
这是因为电脑与输入设备键盘鼠标之间还有一个shell程序，shell程序会进行行编辑，识别键盘输入的信号并转化为计算机能够识别的字符，在我们按下回车之前这些内容一直保存在计算机的缓冲区里没有传入计算机，当我们回车后，shell识别到回车并将回车符和字符串一并输入（结尾有回车），然后计算机程序的getchar()就会一个一个字符去读入，并等待我们继续输入其他值，我们输入其他值后，shell将0消去然后将识别到的字符放在上一个回车之后，这样循环往复，直到我们输入ctrl+z，shell识别输入EOF（-1）给getchar，标志文本输入结束
### 字符串函数头文件 <string.h>
1. strlen(const char *s);  

返回字符串的长度（不计入末尾的0）；输入标准格式是%lu
2. int strcmp(const char *a, const char *b);

比较两个字符串；  
 - a == b 返回0；
 - 不相等时返回两者的差值（int a - int b） 
 
 3. char \*strcpy(char \*restrict dst, char \*restrict src);

* 把src的字符串拷贝到dst里去
* restrict表明scr和dst不重叠（C99）
* 返回dst
* 注意前面是要被粘贴的字符串，后面是被复制的字符串

复制一个字符串
```C
char *dst = (char *)malloc(strlen(char *scr) + 1);
strcpy(dst, scr);
free(dst);
```

4. char \*strcat(char \*restrict s1, char \*restrict s2 );

* 把s2拷贝到s1的后面，接成一个长的字符串，返回s1
* 注意：s1必须要有足够的空间（动态分配内存空间，同上）

5. 安全问题

由于strcpy和strcat都要求被粘贴的字符串的长度要大于被复制的字符串，我们无法去预知，所以下面提供一个安全的版本

* char \*strncpy(char \*restrict dst, char \*restrict src, size_t n);
* char \*strncat(char \*restrict s1, char \*restrict s2, size_t n);
* (这里的n是指你打算让计算机复制粘贴几个字符，可以预先规定，因此是安全的)
* int strncmp(const char *a, const char *b, size_t n);
* (这里的n是指让计算机去比较几个字符（从第0位开始）)

6.字符串搜索函数：
1. char \*strchr(const char \*s, int c);
   - 从左开始找，找到返回指针并指向找到的字符，找不到返回null
2. char \*strrchr(const char \*s, int c);
   - 从右开始找，找到返回指针并指向找到的字符，找不到返回null

**那怎么找第二个呢？**
```C
char s[] = "hello";
char *p = strchr(s, 'l');
p = strchr(p + 1, 'l');
```
3.char \*strstr(const \*s1, const \*s2);
  - 在s1中找s2这个字符串

4.char \*strcasestr(const \*s1, const \*s2);
  -在s1中无视大小写差别找s2这个字符串
















 
