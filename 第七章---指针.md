# 指针
首先来看看逻辑运算符&  

`scanf("%d", &a);`   
这里的&能够获得变量的地址，它的操作数必须是变量   

获取某变量的地址  
`printf("%p", &i);`    
地址的嘻嘻傲娇是否和int想通过取决于编译器的位数  

**&不能取到没有地址的东西，也就是不是变量的东西（比如常量，运算表达式）**  

相邻的变量的地址之间相隔4个字节  
## 什么是指针
指针就是保存地址的变量   
```C
int i;
int *p, q;
int *p = &i;----指针赋值（一定要在使用指针前完成）
```
**这里的q仍是有具体值的变量，不是指针变量**  

## 指针变量
变量的值是内存的地址  
  - 普通变量的值是实际的值
  - 指针变量的值是具有实际值的变量的地址

## \*p的\*
\*的含义是访问那个地址上的变量
  - \*是一个单目运算符，用来访问指针的值所表示的地址上的变量
  - 可以做右值和左值，左值被修改，右值被访问

**注意左值之所以叫左值，是因为赋值号左边的不是变量而是一个值，表达式计算的结果
##  指针的运算符&、\*
一个是得到变量的地址，一个是通过得到地址去访问变量，起相反的作用

## 指针应用场景
1. 当函数返回多个值时，由于函数本身只能返回一个值，所以有些值只能通过指针返回，传入的参数实际上时需要保存带回的结果的变量  

实例：交换值

2. 函数返回运算的状态，结果通过指针返回。常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错。比如用-1和0来表示出错  
    但是当任何数值都是有效的可能结果时，就得用指针来返回值  
    
实例：除法异常判断



### 指针最常见的错误
定义了指针变量，还没有只想任何变量，就开始使用指针
 
## 数组变量是特殊的指针
* 数组变量本身就代表地址，所以无需用&去取数组的地址，数组的地址就是数组的值，但是数组的单元就是变量，需要用&取到地址
  - `int *p = a;`
  - `int *p = &a[0];`
* \[]运算符可以对数组做，也可以对指针做
  - p\[0]==a\[0]

* 数组变量是const的指针
## 指针与const
* 所指的是const

  - 表示不能通过这个指针去修改那个变量
  - ` const int *p = &i;`
  - 变量i仍可以修改，指针p也可以继续指向其他地方，但是不能通过指针去修改变量i
  - `*p = 39`---报错

* 指针是const

  - 表示一旦得到了某个变量的地址，不能再指向其他的变量，即通过固定的指针访问变量
  - ` int *const p = &a; `---p是const

### 辨别方法：看const的位置，在\*之前被指的是const，在\*之后指针是const

## const数组
* `const int a[] = {0,1,2,};`
* 表明数组变量已经是const的指针了，不能再通过数组来对内部的单元进行修改了
* 也就是数组单元都是const变量
* 必须要初始化
* 应用：保护数组值
  - 因为数组传入函数是传入一个地址，所以函数可能通过这个地址对数组内部的元素进行修改，为保护数组的元素，可以设置参数为`const int a[]`
  



  




