# 指针
首先来看看逻辑运算符&  

`scanf("%d", &a);`   
这里的&能够获得变量的地址，它的操作数必须是变量   

获取某变量的地址  
`printf("%p", &i);`    
地址是否和int相等取决于编译器的位数  

**&不能取到没有地址的东西，也就是不是变量的东西（比如常量，运算表达式）**  

相邻的变量的地址之间相隔4个字节  
## 什么是指针
指针就是保存地址的变量   
```C
int i;
int *p, q;
int *p = &i;----指针赋值（一定要在使用指针前完成）
```
**这里的q仍是有具体值的变量，不是指针变量**  

## 指针变量
变量的值是内存的地址  
  - 普通变量的值是实际的值
  - 指针变量的值是具有实际值的变量的地址

## \*p的\*
\*的含义是访问那个地址上的变量
  - \*是一个单目运算符，用来访问指针的值所表示的地址上的变量
  - 可以做右值和左值，左值被修改，右值被访问

**注意左值之所以叫左值，是因为赋值号左边的不是变量而是一个值，表达式计算的结果
##  指针的运算符&、\*
一个是得到变量的地址，一个是通过得到地址去访问变量，起相反的作用

## 指针应用场景
1. 当函数返回多个值时，由于函数本身只能返回一个值，所以有些值只能通过指针返回，传入的参数实际上时需要保存带回的结果的变量  

实例：交换值

2. 函数返回运算的状态，结果通过指针返回。常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错。比如用-1和0来表示出错  
    但是当任何数值都是有效的可能结果时，就得用指针来返回值  
    
实例：除法异常判断



### 指针最常见的错误
定义了指针变量，还没有只想任何变量，就开始使用指针
 
## 数组变量是特殊的指针
* 数组变量本身就代表地址，所以无需用&去取数组的地址，数组的地址就是数组的值，但是数组的单元就是变量，需要用&取到地址
  - `int *p = a;`
  - `int *p = &a[0];`
* \[]运算符可以对数组做，也可以对指针做
  - p\[0]==a\[0]

* 数组变量是const的指针
## 指针与const
* 所指的是const

  - 表示不能通过这个指针去修改那个变量
  - ` const int *p = &i;`
  - 变量i仍可以修改，指针p也可以继续指向其他地方，但是不能通过指针去修改变量i
  - `*p = 39`---报错

* 指针是const

  - 表示一旦得到了某个变量的地址，不能再指向其他的变量，即通过固定的指针访问变量
  - ` int *const p = &a; `---p是const

### 辨别方法：看const的位置，在\*之前被指的是const，在\*之后指针是const

## const数组
* `const int a[] = {0,1,2,};`
* 表明数组变量已经是const的指针了，不能再通过数组来对内部的单元进行修改了
* 也就是数组单元都是const变量
* 必须要初始化
* 应用：保护数组值
  - 因为数组传入函数是传入一个地址，所以函数可能通过这个地址对数组内部的元素进行修改，为保护数组的元素，可以设置参数为`const int a[]`
  
## 指针运算
1. +/-n
  - 由于不同的类型在内存中占用的字节长度不同，为保证指针运算后对应的变量为另一个变量，指针+1的这个单位实际上是指针类型的单位大小，这样就能保证这个地址跳出一个类型变量的范围，进入下一个变量。

* 指针+n表示让指针指向下n个变量；-n表示让指针指向上n个变量
* 递增递减++/--
   - 让指针挪到下/上一个变量

2. 指针加减指针

两个指针之间相差几个变量  
3. \*p++：数组的遍历
  - \*p++：\*p++本身读取的变量仍是上一个变量，但指针p已经指到下一个变量去了
  - 常用于数组类的连续空间操作
  - 在某些cpu上，这可以直接被翻译成一条汇编指令

4. 指针比较

* < > <= >= != ==

## 0地址
* 内存中是有0这个地址的，但这个地址不能随便使用，所以你的指针不能具有0值
* 但可以用0地址来表示特殊的事情

  - 返回的指针是无效的
  - 指针没有被真正的初始化，先初始化为0，这是一个好习惯，看看有没有再初始化为真正的地方

* NULL是一个预定定义的符号，表示0地址
* 有些编译器不希望你用0来表示0地址

## 指针的类型
* 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址，但是指向不同类型的指针是不能直接相互赋值的，这是为了防止指针用错
* 比如：我们用int指针去被char指针赋值，int指针指向一个char变量，当用int指针去修改这个变量时，会导致它后面3个变量被同时修改，因为一个int和char所占有的地址的大小是不一样的

## 指针的类型转化
* viod\*表示不知道指向什么东西的指针，即使是时与char\*相同（但不相通）
* 指针也可以转换类型  

```C
int *p = &i;
void *q = (void*) p;
```
 这并没有改变指针指向的变量的类型，而是指用指针q去看待这个变量时，这个变量的类型就变为void了
 
 ## 指针的动态访问内存（重点）
 先给出一段代码实现对数组a的动态内存分配（在不确定数组的大小的情况下自定义数组的大小）
 ```C
 #include<stdio.h>
 #include<stdlib.h>
 int main(void){
 int number;
 int *a;
 int i;
 printf("请输入数组的个数：\n");
 scanf("%d", &number);
 a = (int*)malloc(number * sizeof(int));
 for(i = 0; i < number; i++){
    scanf("d", &a[i]);
 }
 for(i = number - 1; i >= 0; i--){
    printf("%d", a[i]);
 }
 free(a);  //借来的空间要还回去，而且要还首个指针，对新手来说容易忘了
 return 0;
 }
 
 ```
 * malloc函数

  - 要使用头文件<stdlib.h>
  - void\* malloc(size_t\*size);
  - 向malloc申请的空间的大小是以字节为单位的
  - malloc返回的结果为void类型，需要自己类型转换
  - (int*)malloc(n\*sizeof(int))
  - 如果空间使用完了则返回0，或者NULL

# free常见问题
* 忘记free
* free过了又free
* 地址变过了，直接去free


    



  




